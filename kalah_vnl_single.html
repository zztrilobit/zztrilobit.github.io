<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script>var KalahBoard=(function(){
	var constructor=function(){
		this.brd=[];
		this.bs=0;
		this.is_tmp=false;	
		
	};
	var proto=constructor.prototype;
    //====================================================================
	// ф-ции для общения с ai
	proto.fill=function(dst){
		var i;
		for(i=0;i<(this.bs+1)*2;i++){dst.brd[i]=this.brd[i]};
	};
	
	proto.doMove=function(player,move) {
		var i ;
		for(i=0;i<move.length;i++) {
			this.moveStep(player,move[i]);
		};
		return this.gameOver();
	};
	
	proto.gameOver=function(){
		var i;
		var cnt=[0,0];
		
		for (i=0;i<this.bs;i++) {
			cnt[0]+=this.brd[this.index(0,i)];
			cnt[1]+=this.brd[this.index(1,i)];
		};
		if ((cnt[0]==0)||(cnt[1]==0)) 
		{ 
	      //print ("GOVER0"+this.brd);
			
			
		}
		if (cnt[0]==0) {
			this.brd[this.k_ind[1]]+=cnt[1];
		};
		if (cnt[1]==0) {
			this.brd[this.k_ind[0]]+=cnt[0];
		};
		if ((cnt[0]==0)||(cnt[1]==0)) {
			for (i=0;i<this.bs;i++) {
				this.brd[this.index(0,i)]=0;
				this.brd[this.index(1,i)]=0;
			};
			//print ("GOVER1"+this.brd);
			
			return true;
		} else {
			return false;
		}
	};
	
	//все возможные ходы
	proto.genMoves=function(player){
		var res=[];
		var i,c;
		this.makeTemp();
		for (c=0;c<this.bs;c++) {
			i=this.index(player,c);
			if (this.brd[i]!=0) {
				this.fill(this.tmp);
				//print('ccc'+this.tmp.brd);
				r=this.tmp.moveStep(player,c);
				//print('sss'+this.tmp.brd);
				if (r) {
					//ход закончился
					res.push([c]);
					
				} 
				else {
					//нужно продолжать
					var a;
					a=this.tmp.genMoves(player);
					if (a.length==0) {
						res.push([c]);
					} else {
						var ii;
						for (ii=0;ii<a.length;ii++) {
							//print('rr11  '+[c].concat(a[ii]));
							res.push([c].concat(a[ii]));
						}
					}
				}
			}
		}
		return res;
	};
	//=============================================
	
	proto.fillBoard=function(s){
		 var i;
		 for (i=0;i<this.bs;i++) {
			 this.brd[i]=s; 
			 this.brd[i+this.bs+1]=s;
		}
		 this.brd[this.bs]=0;
		 this.brd[this.bs*2+1]=0;
	};
	
	// клонирует доску в пустую
	proto.clone = function(akb) {
		akb.makeBoard(this.bs);
	    this.fill(akb);
	};
	
	//заполняет только поле с фишками
	
	//создает временую доску для расчета цепочек шагов
	proto.makeTemp=function() {
		if (!this.is_tmp) {
			this.is_tmp=true;
			this.tmp=new KalahBoard();
			this.tmp.makeBoard(this.bs)
		}
	};
	
	//форматирует массив под размер поля
	proto.makeBoard=function(bs){
		this.brd=[];
		this.bs=bs;
		var i;
		for(i=0;i<(bs+1)*2;i++){this.brd.push(0)};
		
		this.k_ind=[bs,bs*2+1];
	};
	
	//индекс игровой лунки в массиве
	proto.index=function(player,cell){return cell+player*(this.bs+1)};
	
	proto.getCell=function(p,i){return this.brd[this.index(p,i)];
	};
	
	//какому игроку принадлежит лунка, соответствующая ячейке? 
	proto.side =function(ind){ return ind<=this.bs ? 0 : 1;};
	
	
	//одиночный посев. если ход окончен - true, не окончен - false
	proto.moveStep=function(player,cell){
		var i=this.index(player,cell);
		var done=false;
		var esc_ind=this.k_ind[1-player];
		var last=this.bs*2+1;
		
		while (!done) {
			// берем из ячейки в руку
			var cc=this.brd[i];
			this.brd[i]=0; 
			//пропускаем калах оппонента
			
			for (;cc>0;) {
				i = (i==last ? 0 : i+1);
				if (i!=esc_ind) { 
					this.brd[i]++;
					cc--;
				};
				
			};
			if (this.side(i)!=player)	{
				//попали на сторону оппонента
				return true ;
			};
			if (i==this.k_ind[player]) {
                //попали в свой калах				
			    return false;
			};
			
			if (this.brd[i]==1) {
				//заберем из противоположной ячейки
				var ocell=this.bs*2-i;
				
				this.brd[this.k_ind[player]]+=this.brd[ocell];
				this.brd[ocell]=0;
				
				return true;
			};
			
		};
	};
	
	// сколько лежит в калахе
	proto.getKala=function(player){
		return this.brd[this.k_ind[player]];
	};
	
	// начальное расположение семян по лункам
	return constructor;
	
})();

/////////////////////////////////////////////////////
// фабрика досок, оценочная ф-ция, предфильтрация ходов для абстрактного алгоритма
var KalahAInterface=(function(){
	var constructor=function(bs){
		this.bs=bs;
		this.boards=[];
		this.inf_plus=100000;
		this.inf_minus=-100000;
		this.cnt_rates=0;
	};
	proto=constructor.prototype;
	
	proto.newBoard=function() {
		
		if (this.boards.length!=0) {
			return this.boards.pop();
		} else {
			var r= new KalahBoard();
			r.makeBoard(this.bs);
			return r;
		};
	};
	proto.reuse=function(b) {
		this.boards.push(b);
	};
	
	proto.filtered_moves=function(b,p){
		return b.genMoves(p);
	};
	
	proto.rate=function(board,player){
		var oplayer=1-player;
		this.cnt_rates++;
		return board.getKala(player)-board.getKala(oplayer);
		
	};
	return constructor;
})();


//============================================================================

var AlphaBeta= (function(){
	var constructor=function() {
		
		
	};
	
	var proto=constructor.prototype;
	/*
	  ###
    integer procedure F2(ref(position) p,integer alpha,integer beta): 
    begin integer m,t; ref(position) q; 
    generate(p); 
    q := first(p); 
    if q = NULL then F2 := f(p) else 
    begin m := alpha; 
     while q <> NULL and m < beta do 
      begin t := -F2(q, -beta, -m); if t > m then m := t; q := next(q); 
      end; 
     F2 := m; 
    end; 
    end.
    ###    
  
	*/
	proto.ABPrun=function(board,iface,player,a,b,depth)
	{
		var res={rate:0};
        if (this.time_check) {
			if ((new Date()).getTime()>this.plan) {
				this.overtaim=true;
				return res;
			};
			
		};
	    //ABPrun:(board,s,a,b,depth)->
		
		//print('prun'+player+" "+a+" "+b+" "+depth)
        this.cnt++;
        var opp=1-player;
        res.best_moves=[];
        
		
		
        if ((depth<=0) || (board.gameOver())) {
            res.rate=iface.rate(board,player);
            res.best_moves=[];
			
            return res;
		};        
			
        var brd = (iface.newBoard());
        var res_rate=iface.inf_minus;
        var best_moves=[];
        
        //#sf=(a,b)-> return b.flips.length-a.flips.length            
        var z=iface.filtered_moves(board,player);
                
        //# а в остальном можно подумать
        res_rate=a;
        
		var i ;
		for(i=0;i<z.length;i++){
			if (this.time_check) {
				if ((new Date()).getTime()>this.plan) {
					this.overtaim=true;
					return res;
				}	;
			
			};
            m=z[i];       
            if (res_rate<b || true) {
                board.fill(brd);
				
                brd.doMove(player,m);
                if (brd.gameOver()) {
                    r=iface.rate(brd,player);
				}
                else r=-this.ABPrun(brd,iface,opp,-b,-res_rate,depth-1).rate;
                if (r>res_rate) res_rate=r;
			}
		};
		iface.reuse(brd);
		res.rate=res_rate;
		res.best_moves=m;
        return res;
	};
	
    proto.bestMoves=function (board,iface,player,depth) {
		
        this.cnt=0
        var opp=1-player;
        if (board.gameOver()) return [];
		
        var brd = iface.newBoard();
		
        var res_rate=iface.inf_minus;
        var best_moves=[];
        
        //#sf=(a,b)-> return b.flips.length-a.flips.length            
        var z=iface.filtered_moves(board,player);
                
        //# а в остальном можно подумать
        var res_rate=iface.inf_minus;
        var result=[];
        var i ;
		for(i=0;i<z.length;i++){
            var m=z[i];
            		
            board.fill(brd);
				
            brd.doMove(player,m);
            
			if (brd.gameOver()) { r=iface.rate(brd,player) } else {
		        r=-this.ABPrun(brd,iface,opp,iface.inf_minus,iface.inf_plus,depth-1).rate
			};
			
			
            if ( r>res_rate ) {
                result=[];
                res_rate=r;
			};
            if (r==res_rate) result.push( m);
		}
		return result;
	};

    proto.move=function (board,iface,side,depth){
		this.time_check=false;
		this.overtaim=false;
		iface.cnt_rates=0;
		var a=this.bestMoves(board,iface,side,depth);
		var i=Math.floor(Math.random() * ( a.length ));
		return a[i];
	};
	
	proto.move_time=function (board,iface,side,depth,ms){
		this.time_check=true;
		
		var d=2, done=false ,  cc=0, result='';
		this.plan=(new Date()).getTime()+ms;
		
		while (!done){
		  iface.cnt_rates=0;
		  
		  this.overtaim=false;
		
		
		  var a=this.bestMoves(board,iface,side,d);
		  // если не уложились по времени, уменьшаем глубину
		  if (!this.overtaim) {
		     var i=Math.floor(Math.random() * ( a.length ));
			 this.real_depth=d;
		     result =a[i];
			 cc=iface.cnt_rates;
			 this.real_depth=d;
			 d++;
		  } else {
			  done=true;
			  iface.cnt_rates=cc;
			  return result;
		    };
		  };
		};
	
	return constructor;
     	
})();            
        
var Utils={
	cust_props: function(res) {
		res.appendTo=function(a){
			a.appendChild(res);
			return res;
		};
		res.css=function(c){
			for (i in c) {
				res.style[i]=c[i];
			};
			return res;
		};
		res.html=function(h){
			res.innerHTML=h;
			return res;
		};
		res.click=function(f){
			res.onclick=f;
			return res;
		};
		res.prepend=function(f){
			res.insertBefore(f,res.firstChild);
		};
		return res;
	},
	
	
	tag: function(t){
		var res= document.createElement(t);
		Utils.cust_props(res);
		//alert(res);
		return res;
    }

};

var KalahView_vanill=(function(){
	var kv=function (){
		this.holes=[[],[]];
		
		this.man=[];
		
		this.view_board='';
	};
	
	
	var proto=kv.prototype;
	
	proto.tag=function(t){
		//alert (t);
		return Utils.tag(t);
	};
	proto.makeBoard=function(bs){
		this.holes=[[],[]];
 		this.man=[];
		this.bs=bs;
		this.view_board=this.tag('table');
		//alert(this.view_board);
		var r1=this.view_board.insertRow(0);
		var styleMan = {
          valign: "middle",
          "text-align": "center",
          width: 60,
          "font-size": "xx-large",
          "font-weight": "bold"
        };
		this.man[1] = Utils.cust_props(r1.insertCell()).css(styleMan);
		var mdl = Utils.cust_props(r1.insertCell());
		this.man[0] = Utils.cust_props(r1.insertCell()).css(styleMan);
		var holes=this.tag('table').appendTo(mdl);
		
		var nh=holes.insertRow();
		var nr=holes.insertRow();
		var sr=holes.insertRow();
		var sh=holes.insertRow();
		var i;
		styleHdr = {
        valign: "middle",
        "text-align": "center",
        width: 60,
        height: 30
      };
      styleBody = {
        valign: "middle",
        "text-align": "center",
        width: 60,
        height: 60,
        "font-size": "xx-large",
        "border-top": "solid",
        "border-bottom": "solid",
        "border-left": "solid",
        "border-right": "solid",
        "border": "1px solid black",
        "border-radius": "20px",
        "padding": "0px"
      };
		for(i=0; i<bs; i++){
			var c;
			c=Utils.cust_props(nr.insertCell()).css(styleBody);
			this.holes[1][bs-i-1]=c;
			//c.appendTo(nr);
			c=Utils.cust_props(sr.insertCell()).css(styleBody);
			this.holes[0][i]=c;
			//c.appendTo(sr);
			Utils.cust_props(sh.insertCell()).css(styleHdr).html(bs-i);
			Utils.cust_props(nh.insertCell()).css(styleHdr).html(i+1);
		}
	};

	proto.click=function(f){
		var i ;
		for (i=0; i<this.bs; i++){
			this.holes[1][i].click(
			  (function(i){ 
			      return (function(){f(1,i);});
				  } )(i)
			);
			this.holes[0][i].click(
			  (function(i){ 
			      return (function(){f(0,i);});
				  } )(i)
			);
		}
		
	};
    // отрисовывает доску наподготовленном отображении	
	proto.draw=function(b){
		var i;
		for (i=0;i<this.bs;i++){
			this.holes[1][i].html(b.getCell(1,i));
			this.holes[0][i].html(b.getCell(0,i));
		};
		this.man[0].html(b.getKala(0));
		this.man[1].html(b.getKala(1));
	};
	
	return kv;
})();
        
		
var KalahGame_vanill=(function(){
	var kg=function(){};
	
	var proto=kg.prototype;
	
	proto.tag=function(t){
		return Utils.tag(t)
	};
	proto.btn=function(txt,f){
		var that=this;
		return this.tag('button').html(txt).click(function(){f.apply(that);});
	};
	
	proto.startGame=function(){
		this.ng(6,6);
		
	};
	
	proto.log_move=function(p,i){
		var v=new KalahView_vanill();
		v.makeBoard(this.bs);
		v.draw(this.board);
		var r=this.tag("div");
		this.tag("div").html('Ход ' + ((p==0)? 'Юга' : 'Севера')+"  "+(this.bs-i)).appendTo(r);
		v.view_board.appendTo(r);
		this.hist_place.prepend(r);
	};
	
	proto.ng=function(bs,seeds){
		this.thinking=false;
		this.bs=bs;
		this.view=new KalahView_vanill();
		this.view.makeBoard(bs);
		this.brd_place.html("");
		this.view.view_board.appendTo(this.brd_place);
	
		this.board=new KalahBoard();
		this.board.makeBoard(bs);
		this.board.fillBoard(bs);
		this.view.draw(this.board);
	  
		this.ki = new KalahAInterface(6);
		this.ab = new AlphaBeta();
		
		var that=this;
		this.view.click(function(p,c){that.onclick(p,c);});
		this.hist_place.html("");
	};
	
	proto.msg=function(m){
		this.alert_place.html(m);
	};
	
	//разворачиваем себя в корневом элементе
	proto.init=function(place){
		place.innerHTML="";
		this.ctrl_place=this.tag("div").appendTo(place);
		
		this.btn('Играть',this.startGame).css({"font-size":"x-large"}).appendTo(this.ctrl_place);
		
		this.brd_place=this.tag("div").appendTo(place);
		this.alert_place=this.tag("div").appendTo(place);
		this.hist_place=this.tag("div").appendTo(place);

	}; 
	
	proto.onclick=function(p,i){
		if (this.thinking) {
			this.msg("север думает, ждите");
			return;
		};
		if (p==1) {
			this.msg("Вы играете за Юг");
			return;
		};
		if (this.board.getCell(0,i)==0){
			this.msg("В лунке ничего нет!");
			return;
		};
		
		this.log_move(0,i);
		var move_done=this.board.moveStep(0,i);
		this.view.draw(this.board);
		
		if (this.board.gameOver()) {
			this.msg("Игра окончена");
			this.view.draw(this.board);
			return;
		};
		if (move_done) {
			var that=this;
			this.msg("думаю....");
			this.thinking=true;
			setTimeout(function(){that.nord_move();},100); 
		} else {
			this.msg("Продолжайте!");
		};
	};
	
	proto.nord_move=function(){
			var m;
			m=this.ab.move_time(this.board,this.ki,1,6,3000);
			var jj;
			for(jj=0;jj<m.length;jj++) {
				this.log_move(1,m[jj]);
				this.board.moveStep(1,m[jj]);
			};
			
			if (this.board.gameOver()) {
				this.msg("Игра окончена");
			};
			this.msg("");
			this.view.draw(this.board);
			this.thinking=false;
			this.msg("Глубина анализа " + this.ab.real_depth +" (" +this.ki.cnt_rates+" позиций)");
	};
	return kg;	
})();

var on_load=(function(){
	//alert(1);
	var g=new KalahGame_vanill();
	g.init(document.getElementById('root'));
	
	
});

//============================================================================
</script>

</head>
<body onload="on_load()">
<div id="root"></div>
</body>
</html>